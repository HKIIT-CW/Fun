<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HKIIT-CW Style Shooter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/tone@14.7.77/build/Tone.js"></script>
    <script src="https://unpkg.com/@tonejs/midi"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            touch-action: none;
            overflow: scroll;
            -webkit-overflow-scrolling: touch;
        }
        ::-webkit-scrollbar {
         -webkit-appearance: none;
         width: 12px !important;
        }

        ::-webkit-scrollbar:vertical {
            width: 12px;
        }

        ::-webkit-scrollbar:horizontal {
            height: 12px;
        }

        ::-webkit-scrollbar-thumb {
            background-color: rgba(0, 0, 0, .5);
            border-radius: 10px;
            border: 2px solid #ffffff;
        }

        ::-webkit-scrollbar-track {
            border-radius: 10px;
            background-color: #ffffff;
        }
        canvas {
            display: block;
        }
        .dark canvas {
            filter: brightness(0.9);
        }
        @keyframes flash {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .flashing {
            animation: flash 0.3s linear infinite;
        }
        .volume-slider {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 6px;
            background: #e5e7eb;
            border-radius: 3px;
            outline: none;
        }
        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #5D5CDE;
            border-radius: 50%;
            cursor: pointer;
        }
        .volume-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #5D5CDE;
            border-radius: 50%;
            cursor: pointer;
        }
        .dark .volume-slider {
            background: #374151;
        }
        .audio-controls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            z-index: 10;
            display: flex;
            align-items: center;
            background-color: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(5px);
            padding: 5px 10px;
            border-radius: 20px;
        }
        .dark .audio-controls {
            background-color: rgba(0, 0, 0, 0.3);
        }
    </style>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        primary: '#5D5CDE',
                    }
                }
            }
        }
    </script>
</head>
<body class="bg-gray-100 dark:bg-gray-900 transition-colors duration-300">
    <div class="container mx-auto px-4 py-5 max-w-2xl">
        <div class="text-center mb-4">
            <h1 class="text-3xl font-bold text-primary mb-2 dark:text-primary">HKIIT Shooting Game(CW)</h1>
            <div class="flex justify-center gap-4 mb-2">
                <p class="text-gray-700 dark:text-gray-300">Score: <span id="score">0</span></p>
                <p class="text-gray-700 dark:text-gray-300">Lives: <span id="lives">3</span></p>
                <p class="text-gray-700 dark:text-gray-300">
                    <span id="powerupStatus" class="hidden">Powerup: <span id="powerupName">CS</span> (<span id="powerupTimer">10</span>s)</span>
                </p>
            </div>
        </div>
        
        <div class="relative bg-blue-50 dark:bg-gray-800 border-2 border-primary rounded-lg overflow-hidden mx-auto" style="max-width: 500px">
            <canvas id="gameCanvas" class="w-full"></canvas>
            <div class="audio-controls">
                <button id="toggleMusic" class="text-white mr-2 focus:outline-none">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path id="audioIcon" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.536 8.464a5 5 0 010 7.072M12 6a9 9 0 010 12M18.364 5.636a9 9 0 010 12.728M21 12a12 12 0 01-12 12" />
                    </svg>
                </button>
                <input type="range" min="0" max="100" value="50" class="volume-slider w-16" id="volumeSlider">
            </div>
            <div id="gameOver" class="absolute inset-0 bg-black bg-opacity-70 flex items-center justify-center flex-col hidden">
                <h2 class="text-white text-3xl font-bold mb-4">Game Over</h2>
                <p class="text-white text-xl mb-6">Final Score: <span id="finalScore" style="color:red;"><b>0</b></span></p>

                <p class="text-white text-xl mb-6">
                    &nbsp;&nbsp;想好似打機咁,輕鬆獲得技能?</br></br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;加入我地啦! HKIIT at CW</br>
                </p>
                <p style="font: size 1px; color:white;">
                    &nbsp;&nbsp;&nbsp;IT114105  軟件工程高級文憑</br>
                    &nbsp;&nbsp;&nbsp;IT114107  遊戲軟件開發高級文憑</br>
                    &nbsp;&nbsp;&nbsp;IT114122  網絡安全高級文憑</br>
                    &nbsp;&nbsp;&nbsp;IT114124  人工智能及智能科技高級文憑</br></br>
                    &nbsp;&nbsp;&nbsp;FS113002N 基礎課程文憑（資訊科技）</br>
                    &nbsp;&nbsp;&nbsp;FS113002S 基礎課程文憑（數碼媒體學）</br></br></br>
                </p>
                
                <button id="restartButton" class="bg-primary text-white px-6 py-2 rounded-lg hover:bg-opacity-90 transition">Play Again</button>
            </div>
            <div id="startScreen" class="absolute inset-0 bg-black bg-opacity-70 flex items-center justify-center flex-col">
                <h2 class="text-white text-3xl font-bold mb-4">Programme Hunting</h2>
                <p class="text-white text-lg mb-3">Click anywhere to move your plane</p>
                <p class="text-white text-lg mb-6">Destroy enemy planes to score points!</p>
                <button id="startButton" class="bg-primary text-white px-6 py-2 rounded-lg hover:bg-opacity-90 transition">Start Game</button>
            </div>
        </div>
        
        <div class="mt-4 text-sm text-gray-600 dark:text-gray-400 max-w-xl mx-auto">
            <p>Click or tap anywhere to move your plane to that position</p>
            <p>Shoot down enemy planes to increase your score</p>
            <p>Collect power-ups (10% chance to drop when defeating enemies):</p>
            <ul class="list-disc ml-5 mt-1">
                <li>CS - Tracking bullets that follow enemies</li>
                <li>GSD - Spread shots that fire in multiple directions</li>
                <li>SE - Three parallel shots covering a wider area</li>
                <li>AIST - Laser beam with high penetration</li>
            </ul>
        </div>
    </div>

    <script>
        // Check for dark mode
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });

        // Game variables
        let canvas, ctx;
        let player, bullets, enemies, explosions, powerups;
        let score, lives, gameRunning, lastTime, spawnTimer;
        let musicInitialized = false;
        let musicPlaying = false;
        let bgMusic, soundEffects;
        
        // Audio setup
        function initAudio() {
            if (musicInitialized) return;
            
            // Setup background music
            bgMusic = {
                synth: new Tone.PolySynth(Tone.Synth).toDestination(),
                isPlaying: false,
                notes: [],
                currentNote: 0,
                tempo: 120,
                
                // Create a simple MIDI-like sequence programmatically
                createSequence() {
                    // Super simple 8-bit style melody
                    const melody = [
                        { note: 'G4', duration: '8n' },
                        { note: 'G4', duration: '8n' },
                        { note: 'F4', duration: '8n' },
                        { note: 'E4', duration: '8n' },
                        { note: 'D4', duration: '8n' },
                        { note: 'C4', duration: '8n' },
                    ];

                    const bassLine = [
                        { note: 'G2', duration: '4n' },
                        { note: 'F2', duration: '4n' },
                        { note: 'E2', duration: '4n' },
                        { note: 'D2', duration: '4n' },
                        { note: 'C2', duration: '4n' },
                        { note: 'B2', duration: '4n' },
                    ];

                    const percussion = [
                        // 用於增加戰爭氛圍的強烈鼓點
                        { note: 'C2', duration: '8n' },
                        { note: 'C2', duration: '8n', rest: true },
                        { note: 'C2', duration: '8n' },
                        { note: 'C2', duration: '8n', rest: true },
                        { note: 'C2', duration: '8n' },
                        { note: 'C2', duration: '8n', rest: true },
                    ];

                    this.notes = [...melody, ...bassLine, ...percussion];
                    this.tempo = 140; // 戰爭緊湊激烈的節拍
                },
                
                play() {
                    if (this.isPlaying) return;
                    this.isPlaying = true;
                    
                    if (this.notes.length === 0) {
                        this.createSequence();
                    }
                    
                    Tone.Transport.bpm.value = this.tempo;
                    
                    // Set up a looping pattern
                    this.pattern = new Tone.Pattern((time, note) => {
                        this.synth.triggerAttackRelease(note.note, note.duration, time);
                    }, this.notes);
                    
                    this.pattern.interval = '8n';
                    this.pattern.start(0);
                    
                    Tone.Transport.start();
                },
                
                stop() {
                    if (!this.isPlaying) return;
                    this.isPlaying = false;
                    
                    if (this.pattern) {
                        this.pattern.stop();
                    }
                    Tone.Transport.stop();
                },
                
                setVolume(vol) {
                    // Convert 0-100 scale to decibels (-60 to 0)
                    const db = vol === 0 ? -Infinity : -60 + (vol * 0.6);
                    this.synth.volume.value = db;
                }
            };
            
            // Sound effects
            soundEffects = {
                shoot: new Tone.Synth({
                    oscillator: { type: 'triangle' },
                    envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.1 }
                }).toDestination(),
                
                explosion: new Tone.NoiseSynth({
                    noise: { type: 'white' },
                    envelope: { attack: 0.001, decay: 0.2, sustain: 0.1, release: 0.1 }
                }).toDestination(),
                
                powerup: new Tone.Synth({
                    oscillator: { type: 'sine' },
                    envelope: { attack: 0.01, decay: 0.1, sustain: 0.6, release: 0.5 }
                }).toDestination(),
                
                playShoot() {
                    this.shoot.triggerAttackRelease('G5', '32n');
                },
                
                playExplosion() {
                    this.explosion.triggerAttackRelease('16n');
                },
                
                playPowerup(type) {
                    const notes = {
                        'CS': 'C6',
                        'GSD': 'E6',
                        'SE': 'G6',
                        'AIST': 'B6'
                    };
                    const note = notes[type] || 'C6';
                    this.powerup.triggerAttackRelease(note, '8n');
                },
                
                setVolume(vol) {
                    // Convert 0-100 scale to decibels (-60 to 0)
                    const db = vol === 0 ? -Infinity : -60 + (vol * 0.6);
                    this.shoot.volume.value = db;
                    this.explosion.volume.value = db;
                    this.powerup.volume.value = db;
                }
            };
            
            // UI controls
            const toggleMusicBtn = document.getElementById('toggleMusic');
            const volumeSlider = document.getElementById('volumeSlider');
            const audioIcon = document.getElementById('audioIcon');
            
            toggleMusicBtn.addEventListener('click', () => {
                if (bgMusic.isPlaying) {
                    bgMusic.stop();
                    audioIcon.setAttribute('d', 'M5.586 15H4a1 1 0 01-1-1V9a1 1 0 011-1h1.586l4.707-4.707A1 1 0 0112 4v16a1 1 0 01-1.707.707L5.586 16z M17 14l3-3 M20 11l-3-3');
                } else {
                    Tone.start().then(() => {
                        bgMusic.play();
                        audioIcon.setAttribute('d', 'M15.536 8.464a5 5 0 010 7.072M12 6a9 9 0 010 12M18.364 5.636a9 9 0 010 12.728M21 12a12 12 0 01-12 12');
                    });
                }
            });
            
            volumeSlider.addEventListener('input', (e) => {
                const volume = parseInt(e.target.value);
                bgMusic.setVolume(volume);
                soundEffects.setVolume(volume);
            });
            
            // Set initial volume
            bgMusic.setVolume(50);
            soundEffects.setVolume(50);
            
            musicInitialized = true;
        }
        
        // Power-up types
        const POWERUP_TYPES = {
            CS: {
                name: "CS",
                color: '#78D2F7', // Purple
                description: "Tracking bullets",
                textColor: "#FFFFFF"
            },
            GSD: {
                name: "GSD",
                color: '#D3308B', // Amber
                description: "Spread shots",
                textColor: "#FFFFFF"
            },
            SE: {
                name: "SE",
                color: '#009B67', // Emerald
                description: "Triple shots",
                textColor: "#FFFFFF"
            },
            AIST: {
                name: "AIST",
                color: '#E2C142', // Blue
                description: "Laser beam",
                textColor: "#FFFFFF"
            }
        };
        
        // Game objects
        class Player {
            constructor(canvas) {
                this.width = 40;
                this.height = 50;
                this.x = canvas.width / 2 - this.width / 2;
                this.y = canvas.height - this.height - 20;
                this.targetX = this.x;
                this.targetY = this.y;
                this.speed = 5;
                this.fireRate = 300; // ms
                this.lastFire = 0;
                this.invulnerable = false;
                this.invulnerableTimer = 0;
                this.powerupType = null;
                this.powerupTimer = 0;
                this.powerupDuration = 10000; // 10 seconds
                this.thrusterAnimation = 0;
            }
            
            update(deltaTime) {
                // Move towards target
                const dx = this.targetX - this.x;
                const dy = this.targetY - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > this.speed) {
                    this.x += (dx / distance) * this.speed;
                    this.y += (dy / distance) * this.speed;
                } else {
                    this.x = this.targetX;
                    this.y = this.targetY;
                }
                
                // Keep player in bounds
                if (this.x < 20) this.x = 20;
                if (this.x + this.width > canvas.width - 20) this.x = canvas.width - 20 - this.width;
                
                // Restrict Y movement to bottom half of screen
                const minY = canvas.height / 2;
                const maxY = canvas.height - 20 - this.height;
                if (this.y < minY) this.y = minY;
                if (this.y > maxY) this.y = maxY;
                
                // Auto fire
                if (gameRunning && Date.now() - this.lastFire > this.fireRate) {
                    this.shoot();
                    this.lastFire = Date.now();
                }
                
                // Update invulnerability
                if (this.invulnerable) {
                    this.invulnerableTimer -= deltaTime;
                    if (this.invulnerableTimer <= 0) {
                        this.invulnerable = false;
                    }
                }
                
                // Update powerup
                if (this.powerupType) {
                    this.powerupTimer -= deltaTime;
                    if (this.powerupTimer <= 0) {
                        this.powerupType = null;
                        document.getElementById('powerupStatus').classList.add('hidden');
                    } else {
                        document.getElementById('powerupTimer').textContent = Math.ceil(this.powerupTimer / 1000);
                    }
                }
                
                // Update thruster animation
                this.thrusterAnimation += 0.1;
            }
            
            shoot() {
                const bulletX = this.x + this.width / 2;
                const bulletY = this.y;
                
                // Play shoot sound effect
                if (musicInitialized && soundEffects) {
                    soundEffects.playShoot();
                }
                
                switch (this.powerupType) {
                    case 'CS': // Tracking bullets
                        bullets.push(new TrackingBullet(bulletX, bulletY));
                        break;
                    case 'GSD': // Spread shots
                        // Center shot
                        bullets.push(new Bullet(bulletX, bulletY));
                        // Spread left and right at angles
                        bullets.push(new SpreadBullet(bulletX, bulletY, -0.2)); // Left
                        bullets.push(new SpreadBullet(bulletX, bulletY, 0.2));  // Right
                        break;
                    case 'SE': // Triple parallel shots
                        bullets.push(new Bullet(bulletX, bulletY));
                        bullets.push(new Bullet(bulletX - 15, bulletY)); // Left
                        bullets.push(new Bullet(bulletX + 15, bulletY)); // Right
                        break;
                    case 'AIST': // Laser beam
                        bullets.push(new LaserBullet(bulletX, bulletY));
                        break;
                    default: // Normal bullet
                        bullets.push(new Bullet(bulletX, bulletY));
                }
            }
            
            draw() {
                if (this.invulnerable && Math.floor(Date.now() / 100) % 2 === 0) {
                    ctx.globalAlpha = 0.5;
                }
                
                // Base colors
                let bodyColor = '#3B82F6';
                let wingsColor = '#2563EB';
                let cockpitColor = '#DBEAFE';
                let thrusterColor = '#EF4444';
                
                // Change colors based on powerup
                if (this.powerupType) {
                    const powerupInfo = POWERUP_TYPES[this.powerupType];
                    if (powerupInfo) {
                        bodyColor = powerupInfo.color;
                        wingsColor = this.adjustColor(powerupInfo.color, -20); // Darker
                        cockpitColor = this.adjustColor(powerupInfo.color, 40); // Lighter
                    }
                }
                
                // Save context for transformations
                ctx.save();
                ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
                
                // Draw thrusters (animated)
                const thrusterHeight = 7 + Math.sin(this.thrusterAnimation * 2) * 3;
                ctx.fillStyle = thrusterColor;
                
                // Left thruster
                ctx.beginPath();
                ctx.moveTo(-14, 20);
                ctx.lineTo(-10, 20 + thrusterHeight);
                ctx.lineTo(-6, 20);
                ctx.closePath();
                ctx.fill();
                
                // Right thruster
                ctx.beginPath();
                ctx.moveTo(6, 20);
                ctx.lineTo(10, 20 + thrusterHeight);
                ctx.lineTo(14, 20);
                ctx.closePath();
                ctx.fill();
                
                // Center thruster
                ctx.beginPath();
                ctx.moveTo(-4, 25);
                ctx.lineTo(0, 25 + thrusterHeight);
                ctx.lineTo(4, 25);
                ctx.closePath();
                ctx.fill();
                
                // Draw main body
                ctx.fillStyle = bodyColor;
                ctx.beginPath();
                ctx.moveTo(0, -25); // Nose
                ctx.lineTo(15, 5); // Right side
                ctx.lineTo(10, 20); // Right back corner
                ctx.lineTo(-10, 20); // Left back corner
                ctx.lineTo(-15, 5); // Left side
                ctx.closePath();
                ctx.fill();
                
                // Draw wings
                ctx.fillStyle = wingsColor;
                
                // Left wing
                ctx.beginPath();
                ctx.moveTo(-15, 0);
                ctx.lineTo(-30, 15);
                ctx.lineTo(-20, 15);
                ctx.lineTo(-10, 5);
                ctx.closePath();
                ctx.fill();
                
                // Right wing
                ctx.beginPath();
                ctx.moveTo(15, 0);
                ctx.lineTo(30, 15);
                ctx.lineTo(20, 15);
                ctx.lineTo(10, 5);
                ctx.closePath();
                ctx.fill();
                
                // Draw canopy
                ctx.fillStyle = cockpitColor;
                ctx.beginPath();
                ctx.ellipse(0, -5, 6, 10, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw canopy highlights
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.beginPath();
                ctx.ellipse(-2, -8, 2, 4, -Math.PI/4, 0, Math.PI * 2);
                ctx.fill();
                
                // Restore context
                ctx.restore();
                
                ctx.globalAlpha = 1;
            }
            
            setInvulnerable(duration) {
                this.invulnerable = true;
                this.invulnerableTimer = duration;
            }
            
            activatePowerup(type) {
                this.powerupType = type;
                this.powerupTimer = this.powerupDuration;
                document.getElementById('powerupStatus').classList.remove('hidden');
                document.getElementById('powerupName').textContent = type;
                document.getElementById('powerupTimer').textContent = Math.ceil(this.powerupTimer / 1000);
            }
            
            // Helper to adjust color brightness
            adjustColor(hex, percent) {
                // Parse the hex color
                let r = parseInt(hex.substring(1, 3), 16);
                let g = parseInt(hex.substring(3, 5), 16);
                let b = parseInt(hex.substring(5, 7), 16);
                
                // Adjust brightness
                r = Math.max(0, Math.min(255, r + percent));
                g = Math.max(0, Math.min(255, g + percent));
                b = Math.max(0, Math.min(255, b + percent));
                
                // Convert back to hex
                return '#' + 
                    ((1 << 24) + (r << 16) + (g << 8) + b)
                    .toString(16).slice(1);
            }
        }
        
        class Bullet {
            constructor(x, y) {
                this.x = x - 2; // Center bullet
                this.y = y;
                this.width = 4;
                this.height = 15;
                this.speed = 10;
                this.damage = 1;
                this.penetrating = false;
            }
            
            update() {
                this.y -= this.speed; // Move up
            }
            
            draw() {
                ctx.fillStyle = '#EF4444';
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }
            
            isOffscreen() {
                return this.y < 0;
            }
        }
        
        class TrackingBullet extends Bullet {
            constructor(x, y) {
                super(x, y);
                this.width = 6;
                this.height = 15;
                this.speed = 8;
                this.target = this.findTarget();
                this.trackingSpeed = 0.1;
                this.damage = 1;
            }
            
            findTarget() {
                // Find closest enemy
                let closest = null;
                let minDist = Number.MAX_VALUE;
                
                for (const enemy of enemies) {
                    const dx = enemy.x - this.x;
                    const dy = enemy.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < minDist) {
                        minDist = dist;
                        closest = enemy;
                    }
                }
                
                return closest;
            }
            
            update() {
                // Move upward
                this.y -= this.speed;
                
                // Update target if needed
                if (!this.target || this.target.isOffscreen()) {
                    this.target = this.findTarget();
                }
                
                // Track target if we have one
                if (this.target) {
                    const targetX = this.target.x + this.target.width / 2;
                    const dx = targetX - this.x;
                    this.x += dx * this.trackingSpeed;
                }
            }
            
            draw() {
                ctx.fillStyle = POWERUP_TYPES.CS.color; // Purple tracking bullet
                ctx.fillRect(this.x - this.width/2, this.y, this.width, this.height);
                
                // Bullet trail
                ctx.strokeStyle = `rgba(${parseInt(POWERUP_TYPES.CS.color.substr(1, 2), 16)}, ${parseInt(POWERUP_TYPES.CS.color.substr(3, 2), 16)}, ${parseInt(POWERUP_TYPES.CS.color.substr(5, 2), 16)}, 0.4)`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x, this.y + 10);
                ctx.stroke();
            }
        }
        
        class SpreadBullet extends Bullet {
            constructor(x, y, angle) {
                super(x, y);
                this.angle = angle; // Radians
                this.speed = 9;
                this.damage = 1;
            }
            
            update() {
                this.y -= Math.cos(this.angle) * this.speed;
                this.x += Math.sin(this.angle) * this.speed;
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(0); // Negative angle because we're moving upward
                ctx.fillStyle = POWERUP_TYPES.GSD.color; // Amber spread bullet
                ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
                
                // Small flame trail
                ctx.fillStyle = '#FBBF24';
                ctx.beginPath();
                ctx.moveTo(0, this.height/2);
                ctx.lineTo(-3, this.height/2 + 5);
                ctx.lineTo(3, this.height/2 + 5);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }
            
            isOffscreen() {
                return this.y < 0 || this.x < 0 || this.x > canvas.width;
            }
        }
        
        class LaserBullet extends Bullet {
            constructor(x, y) {
                super(x, y);
                this.width = 8;
                this.height = 80;
                this.speed = 12;
                this.damage = 2;
                this.penetrating = true; // Goes through enemies
            }
            
            draw() {
                // Main beam
                ctx.fillStyle = POWERUP_TYPES.AIST.color; // Blue laser
                ctx.fillRect(this.x - this.width/2, this.y - this.height, this.width, this.height);
                
                // Glow effect
                ctx.save();
                //ctx.shadowColor = POWERUP_TYPES.AIST.color;
                //ctx.shadowBlur = 15;
                //ctx.fillStyle = gradient;
                ctx.fillRect(this.x - this.width/4, this.y - this.height, this.width/2, this.height);
                ctx.restore();
                
                // Energy core at front
                ctx.fillStyle = '#DBEAFE';
                ctx.beginPath();
                ctx.arc(this.x, this.y - this.height + 5, 5, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        class Enemy {
            constructor(canvas) {
                this.width = 40;
                this.height = 50;
                this.x = Math.random() * (canvas.width - this.width - 40) + 20;
                this.y = -this.height;
                this.speed = 2 + Math.random() * 2;
                this.health = 1;
                this.movementPattern = Math.floor(Math.random() * 3); // 0: straight, 1: zigzag, 2: wave
                this.movementTimer = 0;
                this.amplitude = 20 + Math.random() * 30; // For zigzag and wave patterns
                this.frequency = 0.02 + Math.random() * 0.03; // For wave pattern
                this.originalX = this.x; // For wave pattern
                
                // Enemy type - appearance variation
                this.type = Math.floor(Math.random() * 3); // 0: fighter, 1: bomber, 2: scout
                
                // Color variations
                this.colors = [
                    { body: '#DC2626', wing: '#B91C1C', cockpit: '#FEE2E2' },  // Red (fighter)
                    { body: '#4B5563', wing: '#1F2937', cockpit: '#E5E7EB' },  // Dark gray (bomber)
                    { body: '#059669', wing: '#047857', cockpit: '#D1FAE5' }   // Green (scout)
                ][this.type];
                
                // Adjust health based on type
                if (this.type === 1) { // Bomber - tougher
                    this.health = 2;
                }
            }
            
            update() {
                // Move down
                this.y += this.speed;
                
                // Apply movement pattern
                this.movementTimer += 1;
                
                if (this.movementPattern === 1) { // Zigzag
                    if (this.movementTimer % 60 < 30) {
                        this.x += Math.sin(this.frequency * this.movementTimer) * 0.5;
                    } else {
                        this.x -= Math.sin(this.frequency * this.movementTimer) * 0.5;
                    }
                } else if (this.movementPattern === 2) { // Wave
                    this.x = this.originalX + Math.sin(this.frequency * this.movementTimer) * this.amplitude;
                }
                
                // Keep in bounds
                if (this.x < 0) this.x = 0;
                if (this.x > canvas.width - this.width) this.x = canvas.width - this.width;
            }
            
            draw() {
                // Save context for transformations
                ctx.save();
                ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
                
                switch (this.type) {
                    case 0: // Fighter
                        this.drawFighter();
                        break;
                    case 1: // Bomber
                        this.drawBomber();
                        break;
                    case 2: // Scout
                        this.drawScout();
                        break;
                }
                
                // Restore context
                ctx.restore();
            }
            
            drawFighter() {
                // Draw main body
                ctx.fillStyle = this.colors.body;
                ctx.beginPath();
                ctx.moveTo(0, 25); // Bottom point
                ctx.lineTo(15, 5); // Right side
                ctx.lineTo(10, -15); // Right front corner
                ctx.lineTo(-10, -15); // Left front corner
                ctx.lineTo(-15, 5); // Left side
                ctx.closePath();
                ctx.fill();
                
                // Draw wings
                ctx.fillStyle = this.colors.wing;
                
                // Left wing
                ctx.beginPath();
                ctx.moveTo(-15, 0);
                ctx.lineTo(-30, -15);
                ctx.lineTo(-20, -15);
                ctx.lineTo(-10, 5);
                ctx.closePath();
                ctx.fill();
                
                // Right wing
                ctx.beginPath();
                ctx.moveTo(15, 0);
                ctx.lineTo(30, -15);
                ctx.lineTo(20, -15);
                ctx.lineTo(10, 5);
                ctx.closePath();
                ctx.fill();
                
                // Draw canopy
                ctx.fillStyle = this.colors.cockpit;
                ctx.beginPath();
                ctx.ellipse(0, 5, 6, 10, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw engine glow
                ctx.fillStyle = '#F59E0B';
                ctx.beginPath();
                ctx.arc(0, 22, 3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            drawBomber() {
                // Draw main body (wider)
                ctx.fillStyle = this.colors.body;
                ctx.beginPath();
                ctx.moveTo(0, 25); // Bottom point
                ctx.lineTo(20, 10); // Right side
                ctx.lineTo(20, -10); // Right front 
                ctx.lineTo(0, -20); // Front point
                ctx.lineTo(-20, -10); // Left front
                ctx.lineTo(-20, 10); // Left side
                ctx.closePath();
                ctx.fill();
                
                // Draw wings
                ctx.fillStyle = this.colors.wing;
                
                // Left wing
                ctx.beginPath();
                ctx.moveTo(-20, 0);
                ctx.lineTo(-35, -5);
                ctx.lineTo(-35, 5);
                ctx.lineTo(-20, 10);
                ctx.closePath();
                ctx.fill();
                
                // Right wing
                ctx.beginPath();
                ctx.moveTo(20, 0);
                ctx.lineTo(35, -5);
                ctx.lineTo(35, 5);
                ctx.lineTo(20, 10);
                ctx.closePath();
                ctx.fill();
                
                // Draw canopy
                ctx.fillStyle = this.colors.cockpit;
                ctx.beginPath();
                ctx.ellipse(0, 0, 8, 6, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw double engine glow
                ctx.fillStyle = '#F59E0B';
                ctx.beginPath();
                ctx.arc(-8, 22, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(8, 22, 3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            drawScout() {
                // Draw triangular shape (faster, sleeker)
                ctx.fillStyle = this.colors.body;
                ctx.beginPath();
                ctx.moveTo(0, 25); // Bottom point
                ctx.lineTo(12, 10); // Right side
                ctx.lineTo(7, -20); // Right front
                ctx.lineTo(0, -25); // Front point
                ctx.lineTo(-7, -20); // Left front
                ctx.lineTo(-12, 10); // Left side
                ctx.closePath();
                ctx.fill();
                
                // Small wings
                ctx.fillStyle = this.colors.wing;
                
                // Left wing
                ctx.beginPath();
                ctx.moveTo(-12, 0);
                ctx.lineTo(-25, -5);
                ctx.lineTo(-20, 5);
                ctx.closePath();
                ctx.fill();
                
                // Right wing
                ctx.beginPath();
                ctx.moveTo(12, 0);
                ctx.lineTo(25, -5);
                ctx.lineTo(20, 5);
                ctx.closePath();
                ctx.fill();
                
                // Draw canopy
                ctx.fillStyle = this.colors.cockpit;
                ctx.beginPath();
                ctx.ellipse(0, 0, 5, 8, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw engine glow (brighter for scout)
                ctx.fillStyle = '#FBBF24';
                ctx.beginPath();
                ctx.arc(0, 20, 4, 0, Math.PI * 2);
                ctx.fill();
            }
            
            isOffscreen() {
                return this.y > canvas.height;
            }
            
            takeDamage(amount) {
                this.health -= amount;
                return this.health <= 0;
            }
        }
        
        class PowerUp {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 30;
                this.height = 30;
                this.speed = 2;
                this.oscillation = 0;
                
                // Randomly select one of the powerup types
                const types = Object.keys(POWERUP_TYPES);
                this.type = types[Math.floor(Math.random() * types.length)];
                this.info = POWERUP_TYPES[this.type];
            }
            
            update() {
                this.y += this.speed; // Move down
                
                // Add slight left and right movement
                this.oscillation += 0.05;
                this.x += Math.sin(this.oscillation) * 0.5;
            }
            
            draw() {
                // Create shining effect
                const glowSize = 2 + Math.sin(this.oscillation * 2) * 2;
                
                // Glow effect
                ctx.save();
                ctx.shadowColor = this.info.color;
                ctx.shadowBlur = 10 + glowSize;
                
                // Draw power-up box
                ctx.fillStyle = this.info.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                
                // Draw border
                ctx.strokeStyle = this.adjustColor(this.info.color, 40);
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x, this.y, this.width, this.height);
                
                ctx.restore();
                
                // Draw text
                ctx.fillStyle = this.info.textColor || '#FFFFFF';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.type, this.x + this.width / 2, this.y + this.height / 2);
            }
            
            isOffscreen() {
                return this.y > canvas.height;
            }
            
            // Helper to adjust color brightness
            adjustColor(hex, percent) {
                // Parse the hex color
                let r = parseInt(hex.substring(1, 3), 16);
                let g = parseInt(hex.substring(3, 5), 16);
                let b = parseInt(hex.substring(5, 7), 16);
                
                // Adjust brightness
                r = Math.max(0, Math.min(255, r + percent));
                g = Math.max(0, Math.min(255, g + percent));
                b = Math.max(0, Math.min(255, b + percent));
                
                // Convert back to hex
                return '#' + 
                    ((1 << 24) + (r << 16) + (g << 8) + b)
                    .toString(16).slice(1);
            }
        }
        
        class Explosion {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 5;
                this.maxRadius = 25;
                this.growth = 2;
                this.opacity = 1;
                
                // Play explosion sound
                if (musicInitialized && soundEffects) {
                    soundEffects.playExplosion();
                }
            }
            
            update() {
                this.radius += this.growth;
                if (this.radius > this.maxRadius / 2) {
                    this.opacity -= 0.05;
                }
                return this.opacity > 0;
            }
            
            draw() {
                ctx.save();
                ctx.globalAlpha = this.opacity;
                
                // Outer glow
                ctx.fillStyle = '#FCD34D';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Middle layer
                ctx.fillStyle = '#F59E0B';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * 0.7, 0, Math.PI * 2);
                ctx.fill();
                
                // Core
                ctx.fillStyle = '#EF4444';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * 0.4, 0, Math.PI * 2);
                ctx.fill();
                
                // Add some particles
                const particleCount = 3;
                const angleStep = (Math.PI * 2) / particleCount;
                
                ctx.fillStyle = '#FBBF24';
                for (let i = 0; i < particleCount; i++) {
                    const angle = i * angleStep + (this.radius * 0.1);
                    const distance = this.radius * 0.8;
                    const particleSize = 2 + Math.random() * 2;
                    
                    const px = this.x + Math.cos(angle) * distance;
                    const py = this.y + Math.sin(angle) * distance;
                    
                    ctx.beginPath();
                    ctx.arc(px, py, particleSize, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }
        
        // Star background
        const stars = [];
        function initStars() {
            //stars.length = 0;
            //const starCount = 0;
            
            // for (let i = 0; i < starCount; i++) {
            //     stars.push({
            //         x: Math.random() * canvas.width,
            //         y: Math.random() * canvas.height,
            //         size: 0.5 + Math.random() * 1.5,
            //         speed: 0.2 + Math.random() * 0.8
            //     });
            // }
        }
        
        function updateStars() {
            // stars.forEach(star => {
            //     star.y += star.speed;
                
            //     // Wrap stars to top when they reach bottom
            //     if (star.y > canvas.height) {
            //         star.y = 0;
            //         star.x = Math.random() * canvas.width;
            //     }
            // });
        }
        
        function renderStars() {
            // const isDarkMode = document.documentElement.classList.contains('dark');
            // ctx.fillStyle = isDarkMode ? 'rgba(255, 255, 255, 0.8)' : 'rgba(255, 255, 255, 0.5)';
            
            // stars.forEach(star => {
            //     ctx.fillRect(star.x, star.y, star.size, star.size);
            // });
        }
        
        // Cloud background
        const clouds = [];
        function initClouds() {
            clouds.length = 0;
            const cloudCount = Math.floor(canvas.width / 200);
            
            for (let i = 0; i < cloudCount; i++) {
                clouds.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    width: 60 + Math.random() * 40,
                    height: 30 + Math.random() * 20,
                    speed: 0.5 + Math.random() * 0.5,
                   opacity: 1 
                });
            }
        }
        
        function updateClouds() {
            clouds.forEach(cloud => {
                cloud.y += cloud.speed * 1.5;
                
                // Wrap clouds to top when they reach bottom
                if (cloud.y - cloud.height > canvas.height) {
                    cloud.y = -cloud.height;
                    cloud.x = Math.random() * canvas.width;
                }
            });
        }
        
        function renderClouds() {
            const isDarkMode = document.documentElement.classList.contains('dark');
            
            clouds.forEach(cloud => {
                const cloudColor = isDarkMode ? 
                    `rgba(30, 41, 59, ${cloud.opacity})` : 
                    `rgba(255, 255, 255, ${cloud.opacity})`;
                
                ctx.fillStyle = cloudColor;
                
                // Draw cloud as a collection of overlapping circles
                const centerX = cloud.x + cloud.width / 2;
                const centerY = cloud.y + cloud.height / 2;
                const radiusX = cloud.width / 2;
                const radiusY = cloud.height / 2;
                
                // Base ellipse
                ctx.beginPath();
                ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Add bumps to make it cloud-like
                // const bumpCount = 6;
                // for (let i = 0; i < bumpCount; i++) {
                //     const angle = (i / bumpCount) * Math.PI * 2;
                //     const bumpX = centerX + Math.cos(angle) * radiusX * 0.7;
                //     const bumpY = centerY + Math.sin(angle) * radiusY * 0.7;
                //     const bumpRadius = (radiusX + radiusY) / 6;
                    
                //     ctx.beginPath();
                //     ctx.arc(bumpX, bumpY, bumpRadius, 0, Math.PI * 2);
                //     ctx.fill();
                // }
            });
        }
        
        // Initialize the game
        function initGame() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            // Set canvas size based on container
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // Initialize audio system
            initAudio();
            
            // Initialize game objects
            player = new Player(canvas);
            bullets = [];
            enemies = [];
            explosions = [];
            powerups = [];
            score = 0;
            lives = 3;
            gameRunning = false;
            lastTime = 0;
            spawnTimer = 0;
            
            // Initialize stars and clouds
            //initStars();
            initClouds();
            
            // Add event listeners
            canvas.addEventListener('click', handleClick);
            canvas.addEventListener('touchstart', handleTouch);
            document.getElementById('startButton').addEventListener('click', startGame);
            document.getElementById('restartButton').addEventListener('click', startGame);
            
            // Initial render
            updateUI();
            gameLoop(0);
        }
        
        function resizeCanvas() {
            const container = canvas.parentElement;
            //const dpr = window.devicePixelRatio || 1;

            canvas.width = container.clientWidth ;
            canvas.height = (window.innerHeight * 0.75);

            canvas.style.width = (container.clientWidth) + "px";
            canvas.style.height = (window.innerHeight * 0.75) + "px";

           
            // Re-initialize stars and clouds after resize
            if (clouds.length === 0) {
                initClouds();
            }
           
        }
        
        function startGame() {
            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('gameOver').classList.add('hidden');
            document.getElementById('powerupStatus').classList.add('hidden');
            
            // Start background music if initialized
            if (musicInitialized && !bgMusic.isPlaying) {
                Tone.start().then(() => {
                    bgMusic.play();
                    const audioIcon = document.getElementById('audioIcon');
                    audioIcon.setAttribute('d', 'M15.536 8.464a5 5 0 010 7.072M12 6a9 9 0 010 12M18.364 5.636a9 9 0 010 12.728M21 12a12 12 0 01-12 12');
                });
            }
            
            // Reset game state
            player = new Player(canvas);
            bullets = [];
            enemies = [];
            explosions = [];
            powerups = [];
            score = 0;
            lives = 3;
            gameRunning = true;
            updateUI();
        }
        
        function updateUI() {
            document.getElementById('score').textContent = score;
            document.getElementById('lives').textContent = lives;
            document.getElementById('finalScore').textContent = score;
        }
        
        function handleClick(e) {
            if (!gameRunning) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            player.targetX = x - player.width / 2;
            player.targetY = y - player.height / 2;
        }
        
        function handleTouch(e) {
            e.preventDefault();
            if (!gameRunning) return;
            
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;    // 考慮 Canvas 縮放比例
            const scaleY = canvas.height / rect.height;

            const x = (e.touches[0].clientX - rect.left) * scaleX;
            const y = (e.touches[0].clientY - rect.top) * scaleY;
            
            player.targetX = x - player.width / 2;
            player.targetY = y - player.height / 2;
        }
        
        function checkCollisions() {
            // Check bullet-enemy collisions
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                let bulletRemoved = false;
                
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    
                    if (
                        bullet.x < enemy.x + enemy.width &&
                        bullet.x + bullet.width > enemy.x &&
                        bullet.y < enemy.y + enemy.height &&
                        bullet.y + bullet.height > enemy.y
                    ) {
                        // Check if enemy is destroyed
                        if (enemy.takeDamage(bullet.damage)) {
                            // Create explosion at enemy position
                            explosions.push(new Explosion(
                                enemy.x + enemy.width / 2,
                                enemy.y + enemy.height / 2
                            ));
                            
                            // 10% chance to drop a power-up
                            if (Math.random() < 0.1) {
                                powerups.push(new PowerUp(
                                    enemy.x + enemy.width / 2 - 15,
                                    enemy.y + enemy.height / 2 - 15
                                ));
                            }
                            
                            // Remove enemy
                            enemies.splice(j, 1);
                            
                            // Increase score
                            score += 10;
                            updateUI();
                        }
                        
                        // Remove bullet unless it's penetrating
                        if (!bullet.penetrating) {
                            bullets.splice(i, 1);
                            bulletRemoved = true;
                            break;
                        }
                    }
                }
                
                if (bulletRemoved) continue;
            }
            
            // Check player-powerup collisions
            for (let i = powerups.length - 1; i >= 0; i--) {
                if (
                    player.x < powerups[i].x + powerups[i].width &&
                    player.x + player.width > powerups[i].x &&
                    player.y < powerups[i].y + powerups[i].height &&
                    player.y + player.height > powerups[i].y
                ) {
                    // Get powerup type before removing
                    const powerupType = powerups[i].type;
                    
                    // Play powerup sound
                    if (musicInitialized && soundEffects) {
                        soundEffects.playPowerup(powerupType);
                    }
                    
                    // Collect power-up
                    powerups.splice(i, 1);
                    player.activatePowerup(powerupType);
                    
                    // Add visual effect based on powerup color
                    const flashColor = POWERUP_TYPES[powerupType].color;
                    const flash = document.createElement('div');
                    flash.classList.add('absolute', 'inset-0', 'z-10');
                    flash.style.backgroundColor = flashColor;
                    flash.style.opacity = '0.3';
                    canvas.parentElement.appendChild(flash);
                    setTimeout(() => flash.remove(), 300);
                }
            }
            
            // Check player-enemy collisions
            if (!player.invulnerable) {
                for (let i = enemies.length - 1; i >= 0; i--) {
                    if (
                        player.x < enemies[i].x + enemies[i].width &&
                        player.x + player.width > enemies[i].x &&
                        player.y < enemies[i].y + enemies[i].height &&
                        player.y + player.height > enemies[i].y
                    ) {
                        // Create explosion at collision point
                        explosions.push(new Explosion(
                            player.x + player.width / 2,
                            player.y
                        ));
                        
                        // Remove enemy
                        enemies.splice(i, 1);
                        
                        // Reduce lives
                        lives--;
                        updateUI();
                        
                        if (lives <= 0) {
                            gameOver();
                            bgMusic.stop();
                        } else {
                            player.setInvulnerable(2000); // 2 seconds invulnerability
                        }
                        
                        break;
                    }
                }
            }
        }
        
        function gameOver() {
            gameRunning = false;
            document.getElementById('gameOver').classList.remove('hidden');
        }
        
        function spawnEnemies(deltaTime) {
            spawnTimer += deltaTime;
            
            // Spawn new enemy every 1-2 seconds
            const spawnRate = 1000 - Math.min(score / 10, 500); // Spawn faster as score increases
            
            if (spawnTimer > spawnRate) {
                enemies.push(new Enemy(canvas));
                spawnTimer = 0;
            }
        }
        
        function update(deltaTime) {
            if (gameRunning) {
                player.update(deltaTime);
                
                // Update stars and clouds (moving background)
                //updateStars();
                updateClouds();
                
                // Update bullets
                for (let i = bullets.length - 1; i >= 0; i--) {
                    bullets[i].update();
                    if (bullets[i].isOffscreen()) {
                        bullets.splice(i, 1);
                    }
                }
                
                // Update enemies
                for (let i = enemies.length - 1; i >= 0; i--) {
                    enemies[i].update();
                    if (enemies[i].isOffscreen()) {
                        enemies.splice(i, 1);
                    }
                }
                
                // Update powerups
                for (let i = powerups.length - 1; i >= 0; i--) {
                    powerups[i].update();
                    if (powerups[i].isOffscreen()) {
                        powerups.splice(i, 1);
                    }
                }
                
                // Update explosions
                for (let i = explosions.length - 1; i >= 0; i--) {
                    if (!explosions[i].update()) {
                        explosions.splice(i, 1);
                    }
                }
                
                // Spawn enemies
                spawnEnemies(deltaTime);
                
                // Check collisions
                checkCollisions();
            }
        }
        
        function render() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw background
            const isDarkMode = document.documentElement.classList.contains('dark');
            ctx.fillStyle = isDarkMode ? '#0F172A' : '#DBEAFE';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw clouds
            renderClouds();
            
            // Draw stars
            renderStars();
            
            // Draw bullets
            bullets.forEach(bullet => bullet.draw());
            
            // Draw powerups
            powerups.forEach(powerup => powerup.draw());
            
            // Draw enemies
            enemies.forEach(enemy => enemy.draw());
            
            // Draw player
            player.draw();
            
            // Draw explosions
            explosions.forEach(explosion => explosion.draw());
        }
        
        function gameLoop(timestamp) {
            // Calculate delta time
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            
            // Update game state
            update(deltaTime);   
            // Render game
            render();
            if (clouds.length === 0) {
                initClouds();
            }
            // Request next frame
            requestAnimationFrame(gameLoop);
        }
        
        // Start the game when the page loads
        window.addEventListener('load', initGame);
    </script>
</body>
</html>
